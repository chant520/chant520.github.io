{"posts":[{"title":"搭建一个vue-cli4+webpack+vant移动端框架","content":" 技术栈：vue-cli4 + webpack4 + vant + axios + less + postcss-px2rem 要包括如下技术点： vue-cli4脚手架 vant按需引入 移动端rem适配 axios拦截封装 util工具类函数封装 vue-router配置 登录权限校验 多环境变量配置 vue.config.js配置 toast组件封装 dialog组件封装 跨域代理设置 webpack打包可视化分析 CDN资源优化 gzip打包优化 首页添加骨架屏 vue初始化项目 vue create [project name] 安装vant # 通过 npm 安装 npm i vant -S # 通过 yarn 安装 yarn add vant 安装babel-plugin-import npm i babel-plugin-import -D 记得加-D因为我们只给开发者使用 配置babel-plugin-import // 在.babelrc 中添加配置 { &quot;plugins&quot;: [ [&quot;import&quot;, { &quot;libraryName&quot;: &quot;vant&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: true }] ] } // 对于使用 babel7 的用户，可以在 babel.config.js 中配置 module.exports = { plugins: [ ['import', { libraryName: 'vant', libraryDirectory: 'es', style: true }, 'vant'] ] }; 按需引入：代码中直接引入 Vant 组件，插件会自动将代码转化为方式二中的按需引入形式 import Vue from 'vue' import { Button } from 'vant' Vue.use(Button) rem 适配 安装px2rem-loader插件 npm install px2rem-loader --save-dev 在 vue.config.js 进行如下配置 css: { // css预设器配置项 loaderOptions: { postcss: { plugins: [ require('postcss-px2rem')({ remUnit: 100 }) ] } } } 在 main.js 设置 html 跟字体大小 function initRem() { let cale = window.screen.availWidth &gt; 750 ? 2 : window.screen.availWidth / 375 window.document.documentElement.style.fontSize = `${100 * cale}px` } window.addEventListener('resize', function() { initRem() }) 使用axios封装请求 安装 npm install axios 设置请求拦截和响应拦截 // 文件 ./src/utils/axios.js import axios from 'axios' import vm from 'vm' const PRODUCT_URL = 'https://xxxx.com' const MOCK_URL = 'http://xxxx.com' let http = axios.create({ baseURL: process.env.NODE_ENV === 'production' ? PRODUCT_URL : MOCK_URL, }) // 请求拦截器 http.interceptors.request.use( (config) =&gt; { // 设置token，Content-Type var token = sessionStorage.getItem('token') config.headers['token'] = token config.headers['Content-Type'] = 'application/json;charset=UTF-8' // 请求显示loading效果 if (config.loading === true) { vm.$loading.show() } return config }, (error) =&gt; { vm.$loading.hide() return Promise.reject(error) } ) // 响应拦截器 http.interceptors.response.use( (res) =&gt; { vm.$loading.hide() // token失效，重新登录 if (res.data.code === 401) { // 重新登录 } return res }, (error) =&gt; { vm.$loading.hide() return Promise.reject(error) } ) 封装 get 和 post 请求方法 // 文件 ./src/utils/axios.js ... function get(url, data, lodaing) { return new Promise((resolve, reject) =&gt; { http .get(url) .then( (response) =&gt; { resolve(response) }, (err) =&gt; { reject(err) } ) .catch((error) =&gt; { reject(error) }) }) } function post(url, data, loading) { return new Promise((resolve, reject) =&gt; { http .post(url, data, { loading: loading }) .then( (response) =&gt; { resolve(response) }, (err) =&gt; { reject(err) } ) .catch((error) =&gt; { reject(error) }) }) } export { get, post } 把 get，post 方法挂载到 vue 实例上 // main.js import { get, post } from './utils/axios' Vue.prototype.$http = { get, post } 工具类函数封装 下面是一个示例 封装方法 // 文件 utils/common.js export default { install (Vue, options) { Vue.prototype.util = { method1(val) { ... }, method2 (val) { ... }, } } 在 main.js 通过 vue.use()注册 import utils from './utils/common' Vue.use(utils) vue-router 配置 vue-router 三种配置方式 // 1、Vue异步组件技术： { path: '/home', name: 'Home', component: resolve =&gt; reqire(['../views/Home.vue'], resolve) } // 2、es6提案的import() { path: '/', name: 'home', component: () =&gt; import('../views/Home.vue') } // 3、webpack提供的require.ensure() { path: '/home', name: 'Home', component: r =&gt; require.ensure([],() =&gt; r(require('../views/Home.vue')), 'home') } 本项目采用的是第二种方式，为了后续 webpack 打包优化。 改变单页面应用的 title router.beforeEach((to, from, next) =&gt; { document.title = to.meta.title }) 登录校验 配置路由的 meta 对象的 auth 属性 const routes = [ { path: '/', name: 'home', component: () =&gt; import('../views/Home.vue'), meta: { title: '首页', keepAlive: false, auth: false }, }, { path: '/mine', name: 'mine', component: () =&gt; import('../views/mine.vue'), meta: { title: '我的', keepAlive: false, auth: true }, }, ] 在路由首页进行判断。 当to.meta.auth为true(需要登录)，且不存在登录信息缓存时，需要重定向去登录页面 router.beforeEach((to, from, next) =&gt; { document.title = to.meta.title const userInfo = sessionStorage.getItem('userInfo') || null if (!userInfo &amp;&amp; to.meta.auth) { next('/login') } else { next() } }) 页面缓存配置 通过配置路由的 meta 对象的 keepAlive 属性值来区分页面是否需要缓存 const routes = [ { path: '/', name: 'home', component: () =&gt; import('../views/Home.vue'), meta: { title: '首页', keepAlive: false, auth: false }, }, { path: '/list', name: 'list', component: () =&gt; import('../views/list.vue'), meta: { title: '列表页', keepAlive: true, auth: false }, }, ] 在 app.vue 做缓存判断 &lt;div id=&quot;app&quot;&gt; &lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;/div&gt; 多环境变量配置 1、在项目根目录中新建.env.* .env.development 本地开发环境配置 NODE_ENV='development' VUE_APP_ENV = 'development' 复制代码 .env.test 测试环境配置 NODE_ENV='test' VUE_APP_ENV = 'test' .env.production 正式环境配置 NODE_ENV='production' VUE_APP_ENV = 'production' 为了在不同环境配置更多的变量，我们在 src 文件下新建一个 config/index // 根据环境引入不同配置 process.env.NODE_ENV const config = require('./env.' + process.env.VUE_APP_ENV) module.exports = config 在同级目录下新建 env.development.js，env.test.js，env.production.js，在里面配置需要的变量。 以 env.development.js 为例 module.exports = { baseUrl: 'http://localhost:8089', // 项目地址 baseApi: 'https://www.mock.com/api', // 本地api请求地址 } 2、配置打包命令 package.json 里的 scripts 不同环境的打包命令 通过 npm run serve 启动本地 通过 npm run test 打包测试 通过 npm run build 打包正式 &quot;scripts&quot;: { &quot;dev&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;test&quot;: &quot;vue-cli-service build --mode test&quot;, } vue.config.js 配置 配置我们项目的东西主要包括 打包后文件输出位置 关闭生产环境 souecemap 配置 rem 转化 px 配置 alias 别名 去除生产环境 console 跨域代理设置 module.exports = { publicPath: './', // 默认为'/' // 将构建好的文件输出到哪里，本司要求 outputDir: 'dist/static', // 放置生成的静态资源(js、css、img、fonts)的目录。 assetsDir: 'static', // 指定生成的 index.html 的输出路径 indexPath: 'index.html', // 是否使用包含运行时编译器的 Vue 构建版本。 runtimeCompiler: false, transpileDependencies: [], // 如果你不需要生产环境的 source map productionSourceMap: false, // 配置css css: { // 是否使用css分离插件 ExtractTextPlugin extract: true, sourceMap: true, // css预设器配置项 loaderOptions: { postcss: { plugins: [ require('postcss-px2rem')({ remUnit: 100, }), ], }, }, // 启用 CSS modules for all css / pre-processor files. vant按需引入一定要开启 requireModuleExtension: true, }, // 是一个函数，允许对内部的 webpack 配置进行更细粒度的修改。 chainWebpack: (config) =&gt; { // 配置别名 config.resolve.alias .set('@', resolve('src')) .set('assets', resolve('src/assets')) .set('components', resolve('src/components')) .set('views', resolve('src/views')) config.optimization.minimizer('terser').tap((args) =&gt; { // 去除生产环境console args[0].terserOptions.compress.drop_console = true return args }) }, // 是否为 Babel 或 TypeScript 使用 thread-loader。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。 parallel: require('os').cpus().length &gt; 1, devServer: { host: '0.0.0.0', port: 8899, // 端口号 https: false, // https:{type:Boolean} open: false, // 配置自动启动浏览器 open: 'Google Chrome'-默认启动谷歌 // 配置多个代理 proxy: { '/api': { target: 'https://www.mock.com', ws: true, // 代理的WebSockets changeOrigin: true, // 允许websockets跨域 pathRewrite: { '^/api': '', }, }, }, }, } webpack 可视化分析 安装 webpack-bundle-analyzer npm install webpack-bundle-analyzer -D 插件配置 在 vue.config.js 配置 const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer') configureWebpack: (config) =&gt; { if (process.env.NODE_ENV === 'production') { config.plugins.push(new BundleAnalyzerPlugin()) } } gzip压缩 安装插件 npm install compression-webpack-plugin -D 配置插件 configureWebpack: (config) =&gt; { if (process.env.NODE_ENV === 'production') { config.plugins.push(new BundleAnalyzerPlugin()) config.plugins.push(new CompressionPlugin({ // gzip压缩配置 test: /\\.js$|\\.html$|\\.css/, // 匹配文件名 threshold: 10240, // 对超过10kb的数据进行压缩 deleteOriginalAssets: false // 是否删除原文件 })) } } 添加骨架屏 安装插件 npm install vue-skeleton-webpack-plugin 配置插件 configureWebpack: (config) =&gt; { config.plugins.push(new SkeletonWebpackPlugin({ webpackConfig: { entry: { app: resolve('./src/common/entry-skeleton.js') } }, minimize: true, quiet: true, router: { mode: 'hash', routes: [ { path: '/', skeletonId: 'skeleton1' }, { path: '/about', skeletonId: 'skeleton2' } ] } })) } ","link":"https://chant520.github.io/da-jian-yi-ge-vue-cli4webpackvant-yi-dong-duan-kuang-jia/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://chant520.github.io/hello-gridea/"}]}